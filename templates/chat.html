{% extends "base.html" %} {% block title %}Chat with {{ recipient.name }}{%
endblock %} {% block header %}
<link
  href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;500;600&display=swap"
  rel="stylesheet"
/>
<link
  rel="stylesheet"
  href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.10.5/font/bootstrap-icons.css"
/>

<style>
  /* --- THEME VARIABLES --- */
  :root {
    --sent-gradient: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    --received-bg: #ffffff;
    --received-text: #111b21;
    --sent-text: #ffffff;

    --time-sent: rgba(255, 255, 255, 0.75);
    --time-rec: #667781;

    --bg-pattern: radial-gradient(#e0e0e0 2px, transparent 2px);
  }

  body {
    font-family: "Poppins", sans-serif;
    background-color: #eef2f5;
  }

  /* --- CARD LAYOUT --- */
  .chat-card {
    background: #ffffff;
    border-radius: 16px;
    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.08);
    overflow: hidden;
    height: 80vh;
    display: flex;
    flex-direction: column;
    border: 1px solid rgba(0, 0, 0, 0.05);
    position: relative;
  }

  /* --- HEADER --- */
  .chat-header {
    padding: 10px 20px;
    background: #ffffff;
    border-bottom: 1px solid #f0f0f0;
    display: flex;
    align-items: center;
    justify-content: space-between;
    z-index: 10;
    height: 65px;
  }

  .profile-group {
    display: flex;
    align-items: center;
    gap: 4px;
    cursor: pointer;
  }

  .avatar-header {
    width: 40px;
    height: 40px;
    border-radius: 50%;
    object-fit: cover;
  }

  .user-info h5 {
    margin: 0;
    font-size: 15px;
    font-weight: 600;
    color: #111b21;
  }
  .status-text {
    margin: 0;
    font-size: 12px;
    color: #667781;
  }

  .status-text.typing {
    color: #667eea;
    font-weight: 600;
    animation: pulse 1.5s infinite;
  }
  @keyframes pulse {
    0% {
      opacity: 0.5;
    }
    50% {
      opacity: 1;
    }
    100% {
      opacity: 0.5;
    }
  }

  /* --- CHAT BODY --- */
  .chat-body {
    flex: 1;
    overflow-y: auto;

    /* FIX 1: Fixed padding prevents text jumping when scrollbar appears */
    padding: 20px;

    background-color: #f7f7f7;
    background-image: var(--bg-pattern);
    background-size: 24px 24px;

    display: flex;
    flex-direction: column;
    align-items: flex-start;
    gap: 4px;

    /* FIX 2: Reserves space for scrollbar so it doesn't break borders */
    scrollbar-gutter: stable;
  }

  .chat-body::-webkit-scrollbar {
    width: 5px;
  }
  .chat-body::-webkit-scrollbar-thumb {
    background: rgba(0, 0, 0, 0.1);
    border-radius: 10px;
  }

  /* --- MESSAGES --- */
  .message-wrapper {
    display: flex;
    align-items: flex-end;
    margin-bottom: 2px;
    width: fit-content;
    max-width: 75%;
  }

  .message-wrapper.sent {
    align-self: flex-end;
    flex-direction: row-reverse;
  }

  .message-wrapper.received {
    align-self: flex-start;
  }

  .avatar-chat {
    width: 28px;
    height: 28px;
    border-radius: 50%;
    object-fit: cover;
    margin-bottom: 4px;
    flex-shrink: 0;
    margin-left: 8px;
    margin-right: 8px;
  }

  /* --- BUBBLES --- */
  .msg-bubble {
    padding: 6px 10px 6px 10px;
    border-radius: 14px;
    font-size: 14.5px;
    line-height: 1.4;
    position: relative;
    box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);

    min-width: 60px;
    display: flex;
    flex-direction: column;
  }

  .msg-text {
    white-space: pre-wrap;
    word-wrap: break-word;
    margin-bottom: 2px;
  }

  .sent .msg-bubble {
    background: var(--sent-gradient);
    color: var(--sent-text);
    border-bottom-right-radius: 2px;
  }

  .sent .msg-text {
    margin-right: 15px;
    display: block;
    box-sizing: border-box;
  }

  .received .msg-bubble {
    background: var(--received-bg);
    color: var(--received-text);
    border-bottom-left-radius: 2px;
  }

  /* --- META INFO --- */
  .msg-meta {
    align-self: flex-end;
    display: flex;
    align-items: center;
    gap: 3px;
    font-size: 10px;
    height: 12px;
    line-height: 1;
    opacity: 0.8;
  }

  .sent .msg-time {
    color: var(--time-sent);
  }
  .received .msg-time {
    color: var(--time-rec);
  }

  .msg-tick i {
    font-size: 13px;
  }
  .tick-read {
    color: #55efc4;
  }
  .tick-sent {
    color: rgba(255, 255, 255, 0.7);
  }

  /* --- FLOATING DATE LABEL --- */
  .floating-date-label {
    position: absolute;
    top: 86px;
    left: 49.5%;
    transform: translateX(-50%);

    align-self: center;
    background-color: #ffffff;
    border: 1px solid #f0f0f0;
    color: #54656f;
    font-size: 11px;
    font-weight: 500;
    padding: 4px 12px;
    border-radius: 12px;
    margin: 15px 0;
    box-shadow: 0 1px 2px rgba(0, 0, 0, 0.05);
    z-index: 900;

    opacity: 0;
    transition: opacity 0.2s ease-in-out;
    pointer-events: none;
  }

  .floating-date-label.show {
    opacity: 1;
  }

  /* --- STANDARD DIVIDER (Non-Sticky) --- */
  .date-divider {
    align-self: center;
    background-color: #ffffff;
    border: 1px solid #f0f0f0;
    color: #54656f;
    font-size: 11px;
    font-weight: 500;
    padding: 4px 12px;
    border-radius: 12px;
    margin: 15px 0;
    box-shadow: 0 1px 2px rgba(0, 0, 0, 0.05);
  }

  /* --- FOOTER --- */
  .chat-footer {
    background: #ffffff;
    padding: 10px 15px;
    display: flex;
    align-items: flex-end;
    gap: 10px;
    border-top: 1px solid #f0f0f0;
  }

  .input-wrapper {
    flex: 1;
    background: #f0f2f5;
    border-radius: 24px;
    padding: 8px 16px;
    display: flex;
    align-items: center;
  }

  #messageInput {
    width: 100%;
    border: none;
    outline: none;
    background: transparent;
    resize: none;
    max-height: 100px;
    overflow-y: auto;
    font-family: "Poppins", sans-serif;
    font-size: 14px;
    padding: 0;
    margin: 0;
    line-height: 1.4;
  }

  .btn-send-round {
    background: var(--sent-gradient);
    width: 42px;
    height: 42px;
    border-radius: 50%;
    border: none;
    color: white;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 18px;
    cursor: pointer;
    transition: transform 0.2s;
    box-shadow: 0 4px 10px rgba(102, 126, 234, 0.4);
    flex-shrink: 0;
  }
  .btn-send-round:active {
    transform: scale(0.95);
  }

  /* --- DYNAMIC FLASH MESSAGE (Toast) --- */
  .chat-flash-message {
    position: absolute;
    top: 10px;
    left: 50%;
    transform: translateX(-50%);
    z-index: 2000;
    width: 90%;
    max-width: 400px;
    padding: 10px 15px;
    border-radius: 8px;
    color: white;
    font-size: 14px;
    text-align: center;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
    opacity: 0;
    transition: opacity 0.3s ease-in-out;
    pointer-events: none;
  }
  .chat-flash-message.flash-danger {
    background-color: #dc3545; /* Bootstrap Danger Red */
  }
  .chat-flash-message.flash-success {
    background-color: #198754; /* Bootstrap Success Green */
  }
  .chat-flash-message.show {
    opacity: 1;
    pointer-events: auto;
  }

  /* --- FIX: HIDE RAW DATES INITIALLY --- */
  .date-label,
  .local-time {
    opacity: 0; /* Invisible by default */
    transition: opacity 0.2s ease-in; /* Smooth fade-in */
  }

  /* We will add this class via JS once the data is ready */
  .date-label.loaded,
  .local-time.loaded {
    opacity: 1;
  }

  /* --- DELETED MESSAGE STATE --- */
  .msg-bubble.deleted {
    background: #f0f2f5 !important; /* Neutral Gray */
    border: 1px solid #e1e4e8;
    box-shadow: none;
  }

  .msg-bubble.deleted .msg-text {
    font-style: italic;
    color: #8c959f;
    font-size: 13.5px;
    display: flex;
    align-items: center;
    gap: 6px;
    white-space: normal !important;
    margin-right: 0 !important;
  }

  .msg-bubble.deleted .msg-meta,
  .msg-bubble.deleted .msg-options-btn {
    display: none !important; /* Hide time/checks/options */
  }

  /* --- MESSAGE OPTIONS DROPDOWN --- */
  .msg-options {
    position: absolute;
    top: 0;
    right: 0;
    opacity: 0;
    transition: opacity 0.2s;
    height: 100%;
    display: flex;
    align-items: start;
    padding: 6px 8px 0 0;
    /* Create a gradient overlay so text doesn't clash */
    background: linear-gradient(
      to left,
      rgba(0, 0, 0, 0.05) 0%,
      transparent 100%
    );
    border-top-right-radius: 14px;
  }

  /* Show options on hover (Desktop) */
  .msg-bubble:hover .msg-options {
    opacity: 1;
  }

  .msg-options-btn {
    background: none;
    border: none;
    color: inherit;
    opacity: 0.6;
    padding: 0;
    cursor: pointer;
  }
  .msg-options-btn:hover {
    opacity: 1;
  }

  /* Dropdown styling fix */
  .dropdown-menu-chat {
    min-width: 120px;
    padding: 0.5rem 0;
    border: none;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
    border-radius: 8px;
    font-size: 14px;
  }
  .dropdown-item-chat {
    padding: 6px 16px;
    cursor: pointer;
    color: #dc3545; /* Red for delete */
    display: flex;
    align-items: center;
    gap: 8px;
  }
  .dropdown-item-chat:hover {
    background-color: #fff5f5;
  }
</style>

<header
  class="masthead"
  style="background-image: url('{{ url_for('static', filename='assets/img/home-bg.jpg') }}'); padding-top: 100px; padding-bottom: 50px;"
>
  <div class="container position-relative px-4 px-lg-5">
    <div class="row gx-4 gx-lg-5 justify-content-center">
      <div class="col-md-10 col-lg-8 col-xl-7">
        <div class="text-center text-white">
          <h1>Chat</h1>
          <span class="subheading">Connect with the community</span>
        </div>
      </div>
    </div>
  </div>
</header>
{% endblock %} {% block content %}
<div class="container px-4" style="margin-bottom: 50px; margin-top: -30px">
  <div class="row justify-content-center">
    <div class="col-md-11 col-lg-9">
      <div class="chat-card">
        <div id="customFlash" class="chat-flash-message flash-danger">
          <span id="customFlashIcon" class="me-2"></span>
          <span id="customFlashText"></span>
        </div>

        <div class="chat-header">
          <div class="profile-group" id="profileGroup">
            <img src="{{ recipient.email | gravatar }}" class="avatar-header" />
            <div class="user-info ms-1">
              <h5>{{ recipient.name }}</h5>
              <p class="status-text" id="userStatus">
                @{{ recipient.username }}
              </p>
            </div>
          </div>

          <div class="dropdown">
            <button
              class="btn btn-link text-dark text-decoration-none"
              style="margin-right: -30px;"
              type="button"
              data-bs-toggle="dropdown"
              aria-expanded="false"
            >
              <i class="bi bi-three-dots-vertical fs-5"></i>
            </button>
            <ul
              class="dropdown-menu dropdown-menu-end shadow border-0"
              style="border-radius: 12px"
            >
              <li>
                <a
                  class="dropdown-item d-flex align-items-center gap-2"
                  href="#"
                  id="toggleBlockBtn"
                >
                  {% if is_blocking_them %}
                  <i class="bi bi-unlock text-success"></i>
                  <span id="blockBtnText">Unblock User</span>
                  {% else %}
                  <i class="bi bi-person-x text-danger"></i>
                  <span id="blockBtnText" class="text-danger">Block User</span>
                  {% endif %}
                </a>
              </li>
            </ul>
          </div>
        </div>

        <div id="floatingDateLabel" class="floating-date-label">Today</div>

        <div class="chat-body" id="chatHistory">
          <div id="loadingSpinner" class="text-center w-100 py-3 mb-3 d-none">
            <div
              class="spinner-border spinner-border-sm text-primary"
              role="status"
              style="
                width: 1.5rem;
                height: 1.5rem;
                border-width: 0.2em;
                position: relative;
                z-index: 1000;
              "
            >
              <span class="visually-hidden">Loading...</span>
            </div>
          </div>

          {% for msg in history %}
          <div
            class="message-wrapper {% if msg.sender_id == current_user.id %}sent{% else %}received{% endif %}"
            id="msg-{{ msg.id }}"
            data-timestamp="{{ msg.timestamp.isoformat() }}"
          >
            <img src="{{ msg.sender.email | gravatar }}" class="avatar-chat" />

            <div class="msg-bubble {% if msg.is_deleted %}deleted{% endif %}">
              {% if msg.is_deleted %}
              <span class="msg-text">
                <i class="bi bi-slash-circle"></i> This message was deleted
              </span>
              {% else %}
              <span class="msg-text">{{ msg.body }}</span>
              {% endif %} {% if not msg.is_deleted %}
              <div class="msg-meta">
                <span
                  class="msg-time local-time"
                  data-utc="{{ msg.timestamp.isoformat() }}"
                ></span>

                {% if msg.sender_id == current_user.id %}
                <span class="msg-tick">
                  {% if msg.is_read %}
                  <i class="bi bi-check2-all tick-read" title="Read"></i>
                  {% else %}
                  <i class="bi bi-check2 tick-sent" title="Delivered"></i>
                  {% endif %}
                </span>
                {% endif %}
              </div>

              {% if msg.sender_id == current_user.id %} {% set time_diff =
              (datetime.now(timezone.utc) - msg.timestamp).total_seconds() /
              3600 %} {% if time_diff < 12 %}
              <div class="msg-options">
                <div class="dropdown">
                  <button
                    class="msg-options-btn"
                    type="button"
                    data-bs-toggle="dropdown"
                    aria-expanded="false"
                  >
                    <i class="bi bi-chevron-down"></i>
                  </button>
                  <ul class="dropdown-menu dropdown-menu-chat">
                    <li>
                      <a
                        class="dropdown-item-chat"
                        onclick="deleteMessage({{ msg.id }})"
                      >
                        <i class="bi bi-trash3"></i> Delete
                      </a>
                    </li>
                  </ul>
                </div>
              </div>
              {% endif %} {% endif %} {% endif %}
            </div>
          </div>
          {% endfor %}
        </div>

        {% if can_message %}
        <div class="chat-footer">
          <form id="chatForm" style="flex: 1">
            <div class="input-wrapper">
              <textarea
                id="messageInput"
                rows="1"
                placeholder="Type a message..."
              ></textarea>
            </div>
          </form>

          <button
            type="submit"
            form="chatForm"
            class="btn-send-round"
            id="sendBtn"
          >
            <i class="bi bi-send-fill"></i>
          </button>
        </div>
        {% else %}
        <div class="p-3 text-center bg-light border-top text-muted small">
          <i class="bi bi-lock-fill me-1"></i>
          {% if recipient.name == "Deleted User" %} This account has been
          deleted. You cannot reply to this conversation. {% elif
          is_blocking_them %} You have blocked this user. Unblock them from the
          menu above to send messages. {% else %} This user does not accept
          private messages. {% endif %}
        </div>
        {% endif %}
      </div>
    </div>
  </div>
</div>

<div class="modal fade" id="blockUserModal" tabindex="-1" aria-hidden="true">
  <div class="modal-dialog modal-dialog-centered">
    <div class="modal-content border-0 shadow">
      <div class="modal-header border-0 pb-0">
        <h5 class="modal-title fw-bold text-danger">Block User?</h5>
        <button
          type="button"
          class="btn-close"
          data-bs-dismiss="modal"
          aria-label="Close"
        ></button>
      </div>
      <div class="modal-body text-muted">
        Are you sure you want to block <strong>{{ recipient.name }}</strong>?
        They will no longer be able to send you private messages.
      </div>
      <div class="modal-footer border-0 pt-0">
        <button
          type="button"
          class="btn btn-light rounded-pill px-4"
          data-bs-dismiss="modal"
        >
          Cancel
        </button>
        <button
          type="button"
          class="btn btn-danger rounded-pill px-4"
          id="confirmBlockBtn"
        >
          Block User
        </button>
      </div>
    </div>
  </div>
</div>

<audio
  id="notifySound"
  src="https://assets.mixkit.co/active_storage/sfx/2354/2354-preview.mp3"
  preload="auto"
></audio>

{% endblock %} {% block scripts %}
<script src="https://cdnjs.cloudflare.com/ajax/libs/blueimp-md5/2.19.0/js/md5.min.js"></script>

<script>
  document.addEventListener("DOMContentLoaded", function () {
    const socket = window.socket;
    const chatHistory = document.getElementById("chatHistory");
    const chatForm = document.getElementById("chatForm");
    const messageInput = document.getElementById("messageInput");
    const userStatus = document.getElementById("userStatus");
    const notifySound = document.getElementById("notifySound");
    const floatingDateLabel = document.getElementById("floatingDateLabel");
    const profileGroup = document.getElementById("profileGroup");
    const loadingSpinner = document.getElementById("loadingSpinner"); // NEW: Spinner Element

    const RECIPIENT_ID = "{{ recipient.id }}";
    const CURRENT_USER_ID = "{{ current_user.id }}";
    const IS_BLOCKING_THEM = {{ 'true' if is_blocking_them else 'false' }};

    // FIX 1: Secure URL assignment (Prevent JS Injection)
    const RECIPIENT_PROFILE_URL =
      "{{ url_for('user_profile', username=recipient.username) }}";
    if (profileGroup) {
      profileGroup.onclick = function () {
        window.location.href = RECIPIENT_PROFILE_URL;
      };
    }

    // FIX 3: Safe Variable Injection using '| safe'
    const CURRENT_USER_AVATAR = "{{ current_user.email | gravatar | safe }}";
    const RECIPIENT_AVATAR = "{{ recipient.email | gravatar | safe }}";

    let typingTimeout = undefined;
    let scrollTimeout = undefined;
    let isTypingSignalSent = false;

    // --- INFINITE SCROLL VARIABLES ---
    let currentPage = 1;
    let isLoadingHistory = false;
    let hasMoreHistory = true;

    // ==========================================
    // UI HELPERS (Flash Messages)
    // ==========================================
    function showFlashMessage(message, type = "danger") {
      const flash = document.getElementById("customFlash");
      const flashText = document.getElementById("customFlashText");
      const flashIcon = document.getElementById("customFlashIcon");

      // Set class based on type
      flash.className = `chat-flash-message flash-${type} show`;
      flashIcon.className =
        type === "danger"
          ? "bi bi-exclamation-triangle-fill"
          : "bi bi-check-circle-fill";
      flashText.innerText = message;

      // Ensure it's in view
      flash.scrollIntoView({ behavior: "smooth", block: "center" });

      setTimeout(() => {
        flash.classList.remove("show");
      }, 3000);
    }

    // Replace old connection alert
    function showConnectionError() {
      showFlashMessage(
        "Connection lost. Please check your internet.",
        "danger",
      );
    }

    // ==========================================
    // BLOCK USER LOGIC (Using Modal)
    // ==========================================
    const toggleBlockBtn = document.getElementById("toggleBlockBtn");
    let blockModalInstance = null;
    
    if (toggleBlockBtn) {
      // Safely initialize the Bootstrap Modal
      const modalEl = document.getElementById('blockUserModal');
      if (modalEl) blockModalInstance = new bootstrap.Modal(modalEl);

      toggleBlockBtn.addEventListener("click", function (e) {
        e.preventDefault();
        
        // --- UPDATED: Use the robust state variable instead of text check ---
        if (!IS_BLOCKING_THEM) {
          // Show the Modal if we want to Block
          if(blockModalInstance) blockModalInstance.show();
        } else {
          // If we are unblocking, just do it directly (No friction)
          executeBlockToggle();
        }
      });
    }

    const confirmBlockBtn = document.getElementById("confirmBlockBtn");
    if (confirmBlockBtn) {
      confirmBlockBtn.addEventListener("click", function () {
        // Hide modal and execute
        if (blockModalInstance) blockModalInstance.hide();
        executeBlockToggle();
      });
    }

    async function executeBlockToggle() {
      const csrfToken = "{{ csrf_token() }}";
      const fetchFn = window.apiFetch || fetch;

      try {
        const response = await fetchFn(`/api/block/${RECIPIENT_ID}`, {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "X-CSRFToken": csrfToken,
          },
        });

        if (!response) return; // Handled by apiFetch
        const data = await response.json();

        if (data.success) {
          window.location.reload();
        } else {
          showFlashMessage(data.error || "Something went wrong.", "danger");
        }
      } catch (err) {
        console.error("Block action failed", err);
        showFlashMessage("Network error occurred.", "danger");
      }
    }

    // --- 1. INITIALIZATION & HELPERS ---

    function getFriendlyDate(dateStr) {
      const date = new Date(dateStr);
      const today = new Date();
      const yesterday = new Date();
      yesterday.setDate(yesterday.getDate() - 1);

      if (date.toDateString() === today.toDateString()) return "Today";
      if (date.toDateString() === yesterday.toDateString()) return "Yesterday";
      return date.toLocaleDateString(undefined, {
        day: "numeric",
        month: "long",
        year: "numeric",
      });
    }

    // New Helper: Standardized Date Divider Creation
    function createDateDivider(isoDateString) {
      const div = document.createElement("div");
      div.className = "date-divider";
      div.setAttribute("data-observer-date", isoDateString);
      // Use getFriendlyDate to ensure "Today" / "Yesterday" logic is applied
      div.innerHTML = `<span class="date-label loaded" data-date="${isoDateString}">${getFriendlyDate(isoDateString)}</span>`;
      return div;
    }

    // Helper: Format YYYY-MM-DD for strict comparison (Fixes Midnight Edge Case)
    function getComparisonDate(dateObj) {
      const year = dateObj.getFullYear();
      const month = String(dateObj.getMonth() + 1).padStart(2, "0");
      const day = String(dateObj.getDate()).padStart(2, "0");
      return `${year}-${month}-${day}`;
    }

    // Format existing server-side rendered dates
    document.querySelectorAll(".date-label").forEach((el) => {
      el.innerText = getFriendlyDate(el.getAttribute("data-date"));
      el.classList.add("loaded");
    });

    document.querySelectorAll(".local-time").forEach((el) => {
      const utc = el.getAttribute("data-utc");
      if (utc)
        el.innerText = new Date(utc)
          .toLocaleTimeString([], {
            hour: "numeric",
            minute: "2-digit",
            hour12: true,
          })
          .toUpperCase();
      el.dataset.localized = "true";
      el.classList.add("loaded");
    });

    // FIX: AUTO-FILL CHECK
    // If messages aren't enough to create a scrollbar, load more immediately.
    setTimeout(() => {
      if (
        chatHistory.scrollHeight <= chatHistory.clientHeight &&
        hasMoreHistory
      ) {
        console.log("Content too short. Auto-loading history...");
        loadOlderMessages();
      }
    }, 100);

    // --- 2. YOUR ORIGINAL SCROLL LOGIC (Manual Calculation) ---
    chatHistory.addEventListener("scroll", function () {
      floatingDateLabel.classList.add("show");

      const containerTop = chatHistory.getBoundingClientRect().top;
      const children = chatHistory.children;
      const scanOffset = 80;

      for (let child of children) {
        // FIX: Skip spinner in scroll scanning
        if (child.id === "loadingSpinner") continue;
        if (!child.classList.contains("message-wrapper")) continue;

        const rect = child.getBoundingClientRect();

        if (rect.bottom > containerTop + scanOffset) {
          const ts = child.getAttribute("data-timestamp");
          if (ts) {
            const newLabel = getFriendlyDate(ts);
            if (floatingDateLabel.innerText !== newLabel) {
              floatingDateLabel.innerText = newLabel;
            }
          }
          break;
        }
      }

      if (scrollTimeout) clearTimeout(scrollTimeout);
      scrollTimeout = setTimeout(() => {
        floatingDateLabel.classList.remove("show");
      }, 1000);

      // Trigger Infinite Scroll logic if near top
      if (chatHistory.scrollTop < 50) {
        loadOlderMessages();
      }
    });

    // --- 3. INFINITE SCROLL LOGIC (Robust History Dividers + Spinner) ---
    async function loadOlderMessages() {
      if (isLoadingHistory || !hasMoreHistory) return;
      isLoadingHistory = true;

      // 1. Show Spinner
      if (loadingSpinner) loadingSpinner.classList.remove("d-none");

      const oldScrollHeight = chatHistory.scrollHeight;
      const nextPage = currentPage + 1;

      try {
        const response = await fetch(
          `/api/chat/${RECIPIENT_ID}/history?page=${nextPage}`,
        );
        const data = await response.json();

        if (data.messages && data.messages.length > 0) {
          // API returns Newest -> Oldest
          data.messages.forEach((msg) => {
            const type =
              String(msg.sender_id) === CURRENT_USER_ID ? "sent" : "received";
            let avatar =
              type === "sent" ? CURRENT_USER_AVATAR : RECIPIENT_AVATAR;

            const msgEl = createMessageElement(
              msg.body,
              type,
              avatar,
              null,
              msg.timestamp,
              msg.is_read ? "read" : "sent",
              msg.id, // <--- PASS REAL ID
              msg.is_deleted, // <--- PASS DELETED STATUS
            );

            // --- HISTORY DIVIDER LOGIC ---
            // Determine the actual top message/divider, IGNORING the spinner
            let currentTop = chatHistory.firstElementChild;
            if (currentTop && currentTop.id === "loadingSpinner") {
              currentTop = currentTop.nextElementSibling;
            }

            if (currentTop) {
              // 1. If Top is a DIVIDER, check if we fit under it
              if (currentTop.classList.contains("date-divider")) {
                const rawDate = currentTop.getAttribute("data-observer-date");

                // CRITICAL SAFETY CHECK: Prevent "split of null" crash
                if (rawDate) {
                  const dividerDate = getComparisonDate(new Date(rawDate));
                  const msgDate = getComparisonDate(new Date(msg.timestamp));

                  if (dividerDate === msgDate) {
                    // Same date. Insert message AFTER divider.
                    if (currentTop.nextSibling) {
                      chatHistory.insertBefore(msgEl, currentTop.nextSibling);
                    } else {
                      chatHistory.appendChild(msgEl);
                    }
                    return;
                  }
                }
              }

              // 2. If Top is a MESSAGE, check if we need a divider between them
              if (currentTop.classList.contains("message-wrapper")) {
                const topTs = currentTop.getAttribute("data-timestamp");
                if (topTs) {
                  // Safety Check: Ensure topTs exists before splitting
                  const topDate = topTs
                    ? getComparisonDate(new Date(topTs))
                    : null;
                  const msgDate = msg.timestamp
                    ? getComparisonDate(new Date(msg.timestamp))
                    : null;

                  if (topDate !== msgDate) {
                    const div = createDateDivider(topTs);
                    chatHistory.insertBefore(div, currentTop);
                  }
                }
              }
            }

            // INSERTION: Insert after spinner (so spinner stays at top)
            if (loadingSpinner && loadingSpinner.parentNode === chatHistory) {
              // Insert immediately after spinner (effectively top of messages)
              if (loadingSpinner.nextSibling) {
                chatHistory.insertBefore(msgEl, loadingSpinner.nextSibling);
              } else {
                chatHistory.appendChild(msgEl);
              }
            } else {
              // Fallback if no spinner found
              chatHistory.insertBefore(msgEl, chatHistory.firstChild);
            }
          });

          // Final Clean: Add divider for the oldest loaded message if needed
          let finalTop = chatHistory.firstElementChild;
          if (finalTop && finalTop.id === "loadingSpinner") {
            finalTop = finalTop.nextElementSibling;
          }

          if (finalTop && finalTop.classList.contains("message-wrapper")) {
            const ts = finalTop.getAttribute("data-timestamp");
            if (ts) {
              const div = createDateDivider(ts);
              chatHistory.insertBefore(div, finalTop);
            }
          }

          currentPage = nextPage;
          hasMoreHistory = data.has_next;

          // Maintain Scroll Position
          const newScrollHeight = chatHistory.scrollHeight;
          chatHistory.scrollTop = newScrollHeight - oldScrollHeight;
        } else {
          hasMoreHistory = false;
        }
      } catch (err) {
        console.error("History load error", err);
      } finally {
        isLoadingHistory = false;

        // 2. Hide Spinner
        if (loadingSpinner) loadingSpinner.classList.add("d-none");

        // RECURSIVE CHECK: Auto-fill if screen still not full
        if (
          chatHistory.scrollHeight <= chatHistory.clientHeight &&
          hasMoreHistory
        ) {
          loadOlderMessages();
        }
      }
    }

    // --- 4. INPUT HANDLERS ---
    if (messageInput) {
      messageInput.addEventListener("input", function () {
        this.style.height = "auto";
        const newH = this.scrollHeight;
        const maxH = 120;
        this.style.height = (newH > maxH ? maxH : newH) + "px";
        this.style.overflowY = newH > maxH ? "auto" : "hidden";

        if (this.value.trim().length > 0) {
          if (!isTypingSignalSent) {
            socket.emit("typing", { recipient_id: RECIPIENT_ID });
            isTypingSignalSent = true;
          }
          if (typingTimeout) clearTimeout(typingTimeout);
          typingTimeout = setTimeout(() => {
            socket.emit("stop_typing", { recipient_id: RECIPIENT_ID });
            isTypingSignalSent = false;
          }, 2000);
        } else {
          if (isTypingSignalSent) {
            socket.emit("stop_typing", { recipient_id: RECIPIENT_ID });
            isTypingSignalSent = false;
          }
        }
      });

      messageInput.addEventListener("keydown", function (e) {
        if (e.key === "Enter" && !e.shiftKey) {
          e.preventDefault();
          chatForm.dispatchEvent(new Event("submit"));
        }
      });
    }

    // --- 5. SOCKET EVENTS & SEND LOGIC ---

    // Shared logic to check/append date divider for NEW messages
    function appendDateDividerIfNeeded() {
      const allDividers = document.querySelectorAll(".date-divider");
      const lastDivider =
        allDividers.length > 0 ? allDividers[allDividers.length - 1] : null;

      const todayIso = getComparisonDate(new Date()); // YYYY-MM-DD
      let lastDividerLocal = null;

      if (lastDivider) {
        const rawDate = lastDivider.getAttribute("data-observer-date");
        // Safety check
        if (rawDate) {
          // Convert the stored UTC string to a Real Date Object (Browser Local Time)
          const dateObj = new Date(rawDate);
          // Extract the LOCAL YYYY-MM-DD from that object
          lastDividerLocal = getComparisonDate(dateObj);
        }
      }

      // FIX: Compare strict Dates, not Text "Today"
      if (lastDividerLocal !== todayIso) {
        const div = createDateDivider(new Date().toISOString());
        chatHistory.appendChild(div);
      }
    }

    if (chatForm) {
      chatForm.addEventListener("submit", function (e) {
        e.preventDefault();

        // FIX 2: Check Connection & Show Flash
        if (!socket.connected) {
          showConnectionError();
          return;
        }

        const text = messageInput.value.trim();
        if (!text) return;

        const tempId = Date.now();

        // 1. Check/Add Divider FIRST
        appendDateDividerIfNeeded();

        // 2. Add Message
        // Note: We don't have the Real ID yet, so we pass null.
        // The socket confirmation will update this later.
        const msgEl = createMessageElement(
          text,
          "sent",
          CURRENT_USER_AVATAR,
          tempId,
          null,
          "clock",
          null, // No Real ID yet
          false, // Not deleted
        );
        chatHistory.appendChild(msgEl);

        messageInput.value = "";
        messageInput.style.height = "auto";
        chatHistory.scrollTop = chatHistory.scrollHeight;

        socket.emit("send_message", {
          recipient_id: RECIPIENT_ID,
          body: text,
          temp_id: tempId,
        });

        if (typingTimeout) clearTimeout(typingTimeout);
        if (isTypingSignalSent) {
          socket.emit("stop_typing", { recipient_id: RECIPIENT_ID });
          isTypingSignalSent = false;
        }
      });
    }

    socket.on("new_message", function (data) {
      if (String(data.sender_id) === RECIPIENT_ID) {
        // 1. Check/Add Divider FIRST
        appendDateDividerIfNeeded();

        // 2. Add Message
        const msgEl = createMessageElement(
          data.body,
          "received",
          RECIPIENT_AVATAR,
          null,
          data.timestamp,
          "read",
          data.id, // <--- Pass ID from socket
          data.is_deleted, // <--- Pass status
        );
        chatHistory.appendChild(msgEl);

        notifySound.play().catch((e) => console.log("Interact first"));
        chatHistory.scrollTop = chatHistory.scrollHeight;
        socket.emit("mark_read", { sender_id: RECIPIENT_ID });
      }
    });

    // TICK LOGIC:
    // --- UPDATED: Message Sent Confirmation ---
    // We need to update the TEMPORARY DOM element with the REAL ID so it can be deleted
    socket.on("message_sent_confirmation", function (data) {
      // Find the element by temp ID
      const wrapper = document.querySelector(
        `[data-temp-id="${data.temp_id}"]`,
      );
      if (wrapper) {
        // Update ID to real ID so delete works
        wrapper.id = `msg-${data.real_id}`;

        // Update Tick
        const icon = wrapper.querySelector(`#tick-${data.temp_id}`);
        if (icon) {
          icon.className = "bi bi-check2 tick-sent";
          icon.id = `tick-${data.real_id}`; // Update tick ID too
        }

        // RE-RENDER BUBBLE TO ADD DELETE BUTTON
        // Since we didn't have the Real ID when creating, we didn't add the dropdown.
        // Now we have it, we can inject the dropdown if < 12h.
        const bubble = wrapper.querySelector(".msg-bubble");
        if (bubble && !bubble.querySelector(".msg-options")) {
          const optionsDiv = document.createElement("div");
          optionsDiv.className = "msg-options";
          optionsDiv.innerHTML = `
                    <div class="dropdown">
                        <button class="msg-options-btn" type="button" data-bs-toggle="dropdown" aria-expanded="false">
                            <i class="bi bi-chevron-down"></i>
                        </button>
                        <ul class="dropdown-menu dropdown-menu-chat">
                            <li><a class="dropdown-item-chat" onclick="deleteMessage(${data.real_id})">
                                <i class="bi bi-trash3"></i> Delete
                            </a></li>
                        </ul>
                    </div>
                `;
          bubble.appendChild(optionsDiv);
        }
      }
    });

    socket.on("messages_read_update", function (data) {
      document
        .querySelectorAll(".tick-sent, .bi-clock, .tick-clock")
        .forEach((icon) => {
          icon.className = "bi bi-check2-all tick-read";
        });
    });

    socket.on("display_typing", function (data) {
      if (String(data.sender_id) === RECIPIENT_ID) {
        userStatus.innerText = "typing...";
        userStatus.classList.add("typing");
      }
    });

    socket.on("hide_typing", function (data) {
      if (String(data.sender_id) === RECIPIENT_ID) {
        userStatus.innerText = "@" + "{{ recipient.username }}";
        userStatus.classList.remove("typing");
      }
    });

    // --- 6. DOM HELPER ---
    function createMessageElement(
      text,
      type,
      avatarUrl,
      tempId = null,
      utcTimestamp = null,
      status = "clock",
      realId = null,
      isDeleted = false,
    ) {
      const wrapper = document.createElement("div");
      wrapper.className = `message-wrapper ${type}`;

      // Store ID for targeting
      if (realId) wrapper.id = `msg-${realId}`;
      if (tempId) wrapper.setAttribute("data-temp-id", tempId);

      const currentIso = utcTimestamp || new Date().toISOString();
      wrapper.setAttribute("data-timestamp", currentIso);

      let timeDisplay = new Date()
        .toLocaleTimeString([], {
          hour: "numeric",
          minute: "2-digit",
          hour12: true,
        })
        .toUpperCase();

      if (utcTimestamp) {
        timeDisplay = new Date(utcTimestamp)
          .toLocaleTimeString([], {
            hour: "numeric",
            minute: "2-digit",
            hour12: true,
          })
          .toUpperCase();
      }

      const avatarImg = document.createElement("img");
      avatarImg.src = avatarUrl;
      avatarImg.className = "avatar-chat";

      const bubbleDiv = document.createElement("div");
      bubbleDiv.className = `msg-bubble ${isDeleted ? "deleted" : ""}`;

      // 1. CONTENT LOGIC
      const textSpan = document.createElement("span");
      textSpan.className = "msg-text";

      if (isDeleted) {
        textSpan.innerHTML = `<i class="bi bi-slash-circle"></i> This message was deleted`;
      } else {
        textSpan.textContent = text;
      }
      bubbleDiv.appendChild(textSpan);

      // 2. META LOGIC (Time + Ticks)
      // Only create and append meta info if NOT deleted
      if (!isDeleted) {
        const metaDiv = document.createElement("div");
        metaDiv.className = "msg-meta";

        // Time
        const timeSpan = document.createElement("span");
        timeSpan.className = "msg-time loaded";
        timeSpan.innerText = timeDisplay;
        metaDiv.appendChild(timeSpan);

        // Ticks (Only for sent messages)
        if (type === "sent") {
          let iconClass = "bi bi-clock tick-clock";
          if (status === "sent") iconClass = "bi bi-check2 tick-sent";
          if (status === "read") iconClass = "bi bi-check2-all tick-read";

          const tickSpan = document.createElement("span");
          tickSpan.className = "msg-tick";
          tickSpan.innerHTML = `<i id="tick-${tempId || realId}" class="${iconClass}"></i>`;
          metaDiv.appendChild(tickSpan);
        }

        bubbleDiv.appendChild(metaDiv); // Add meta to bubble
      }

      // 3. DELETE OPTION (Dropdown)
      // Only show if: Sent by me, Not Deleted, Has Real ID, within 12 hours (Frontend check approx)
      if (type === "sent" && !isDeleted && realId) {
        const msgDate = new Date(currentIso);
        const now = new Date();
        const hoursDiff = (now - msgDate) / 1000 / 60 / 60;

        if (hoursDiff < 12) {
          const optionsDiv = document.createElement("div");
          optionsDiv.className = "msg-options";
          optionsDiv.innerHTML = `
                    <div class="dropdown">
                        <button class="msg-options-btn" type="button" data-bs-toggle="dropdown" aria-expanded="false">
                            <i class="bi bi-chevron-down"></i>
                        </button>
                        <ul class="dropdown-menu dropdown-menu-chat">
                            <li><a class="dropdown-item-chat" onclick="deleteMessage(${realId})">
                                <i class="bi bi-trash3"></i> Delete
                            </a></li>
                        </ul>
                    </div>
                `;
          bubbleDiv.appendChild(optionsDiv);
        }
      }

      wrapper.appendChild(avatarImg);
      wrapper.appendChild(bubbleDiv);

      return wrapper;
    }

    // --- NEW: GLOBAL DELETE FUNCTION ---
    window.deleteMessage = function (msgId) {
      // Use apiFetch from base.html if available, or fetch with CSRF
      const csrfToken = "{{ csrf_token() }}";

      // Assuming apiFetch is available in global scope from base.html, otherwise fallback to fetch
      const fetchFn = window.apiFetch || fetch;

      fetchFn(`/api/message/${msgId}/delete`, {
        method: "POST",
        headers: {
          // apiFetch adds CSRF automatically, but if using standard fetch we need it
          "Content-Type": "application/json",
          "X-CSRFToken": csrfToken,
        },
      })
        .then((response) => {
          // apiFetch handles redirections (e.g. 401) returning null
          if (!response) return null;
          return response.json();
        })
        .then((data) => {
          if (data && data.error) {
            // FIX: Replaced native alert with custom flash message
            showFlashMessage(data.error, "danger");
          }
          // Success is handled by the socket event 'message_deleted'
        })
        .catch((err) => {
          console.error(err);
          // FIX: Replaced silent fail with custom flash message
          showFlashMessage("Network error occurred.", "danger");
        });
    };

    // --- NEW: LISTEN FOR DELETION ---
    socket.on("message_deleted", function (data) {
      const msgId = data.message_id;
      const wrapper = document.getElementById(`msg-${msgId}`);

      if (wrapper) {
        const bubble = wrapper.querySelector(".msg-bubble");
        if (bubble) {
          // Apply Deleted Styling
          bubble.className = "msg-bubble deleted";

          // Replace Content
          const textSpan = bubble.querySelector(".msg-text");
          textSpan.innerHTML = `<i class="bi bi-slash-circle"></i> This message was deleted`;

          // Remove Meta & Options
          const meta = bubble.querySelector(".msg-meta");
          if (meta) meta.remove();
          const options = bubble.querySelector(".msg-options");
          if (options) options.remove();
        }
      }
    });

    // --- 7. NEW: RENDER INITIAL DIVIDERS (The Fix) ---
    function renderInitialDividers() {
      // Select only messages (ignore spinner)
      const messages = Array.from(
        chatHistory.querySelectorAll(".message-wrapper"),
      );
      let lastDateKey = null;

      messages.forEach((msg) => {
        const ts = msg.getAttribute("data-timestamp");
        if (!ts) return;

        // Convert UTC timestamp to LOCAL Date String (YYYY-MM-DD)
        // This solves the 5:30 AM bug
        const dateObj = new Date(ts);
        const localDateKey = getComparisonDate(dateObj);

        if (localDateKey !== lastDateKey) {
          // Create divider
          const div = createDateDivider(ts);
          // Insert BEFORE the current message
          chatHistory.insertBefore(div, msg);
          lastDateKey = localDateKey;
        }
      });
    }

    // --- EXECUTE ON LOAD ---
    renderInitialDividers();

    // Scroll to bottom AFTER rendering dividers (to account for their height)
    chatHistory.scrollTop = chatHistory.scrollHeight;
  });
</script>
{% endblock %}
